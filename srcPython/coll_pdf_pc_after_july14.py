# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

#copy of coll_pdf_pc.py on july 16 2018. then modif for paper ca3 (collision avoidance cygnss) 
# this script genreates a PDF of Pc values. THe probability of a Pc to occur is defined by the probability of the set (f107, Ap) to occur. This is claculated in the script 45d_uncertainty_f107_ap.py and reported in the files 'f107_ap_forecast_error_day_' + str(epoch_to_tca) + '.txt', which thus need to be in the directory where this script is run


# ASSUMPTIONS:
# - first 5 chracters of each run name in filename_results_pc needs to be: mmmdd. ex: nov01. Also, the scripts assume that epoch and TCA are at the same year... This is only at the line where "epoch" is calculated. 
# - the files 'f107_ap_forecast_error_day_' + str(epoch_to_tca) + '.txt' generated by 45d_uncertainty_f107_ap.py need to be in the directory where you run this script from

import sys

#sys.path.append("/home1/cbussy/Code/spock/srcPython")
sys.path.append("/Users/cbv/Google Drive/Work/PhD/Research/Code/spock/srcPython")
import matplotlib
import pickle
from orbit_average import *
import matplotlib.colors as colors
import matplotlib.cm as cmx
from cadre_read_last_tle import *
from get_prop_dir import *
import matplotlib.gridspec as gridspec
from read_input_file import *
from read_output_file import *
from matplotlib.colors import LogNorm
from norad_id_to_cygnss_name import *
import pickle
from eci_to_lvlh import *
import fileinput
import time
from datetime import datetime
import numpy as np
from matplotlib import pyplot as plt
import os
import sys
import subprocess
from get_name_mission import *
from find_in_read_input_order_variables import *
from mpl_toolkits.mplot3d import Axes3D
import pandas as pd


show_plot = 0

if show_plot  == 1:
    plt.ion()

# line belwo: Pc computed by CARA using the same VCMs as SpOCK. The value is reported in the CDMs. I tried ot read the vlaue uatomaiically from the file but it requires to read an excel file and the xlrd modeule isnt installed in Pleaides so the pandas functions crash. So tenter the value manually here and make sure to look at the CDM that was computed using the same VCM as in SpOCK. The excel file Cygnss_Events_with_hbr.xlsx maps the VCMs and CDMs. By the way, the HBR in the excel file is the sum of the primary AND secondary HBR,




filename_results_pc = "out_" + sys.argv[1]# 'out_test_runlist_FM07_nov01_hbr_2_5.txt'#'out_runlist_FM07_nov01_hbr_2_5.txt'#'out_runlist_FM07_nov01_30000ens.txt'
file_results_pc = open(filename_results_pc)
read_file_results_pc = file_results_pc.readlines()



pc = [] 
f107 = []
ap = []
tca = []
dca = []

nb_run = len(read_file_results_pc)
# read the first tca to get an idea of when the clsoe approach occurs. This will be used to select the correct f107/ap forecast error dsitirbution (that are genreated every day of the prediction horizon)
iline = 0
found_tca = 0
while (iline < nb_run) & (found_tca == 0):
    if read_file_results_pc[iline].split()[2] != '-1':
        found_tca = 1
        tca_for_f107_ap = read_file_results_pc[iline].split()[2]
        tca_for_f107_ap_date = datetime.strptime(tca_for_f107_ap, "%Y-%m-%dT%H:%M:%S.%f")
        epoch  = read_file_results_pc[iline].split()[0][:5] # !!! assumes first 5 chracters of each run name in filename_results_pc needs to be: mmmdd. ex: nov01
        epoch_date = datetime.strptime(tca_for_f107_ap[:4] + epoch, "%Y%b%d") # !!!! assumes TCA and epoch are in same year
    iline = iline + 1
epoch_to_tca = (int)(round((tca_for_f107_ap_date-epoch_date).total_seconds() / 3600./24))
if epoch_to_tca == 0:
    epoch_to_tca = 1

# determine whcih f107 and ap forecast error distirbution to use
filename_f107_ap_forecast_error_dist = 'f107_ap_forecast_error_day_' + str(epoch_to_tca) + '.txt'
file_f107_ap_forecast_error_dist = open(filename_f107_ap_forecast_error_dist)
read_file_f107_ap_forecast_error_dist = file_f107_ap_forecast_error_dist.readlines()
# The bin ranges are defined by the number of bins and the range in the functino .hist used in 45d_uncertainty_f107_ap.py to caclaulte hist_f107 and hist_ap. So need to make sure that this f107_bin_range and ap_bin_range are the same as the result of the function .hist (coordinate [1] of the result of cuntion hist). This is also used in the script deviation_swpc_f107_ap.py
f107_bin_range = np.zeros([len(read_file_f107_ap_forecast_error_dist[3].split())])
for i in range(len(read_file_f107_ap_forecast_error_dist[3].split())):
    f107_bin_range[i] = read_file_f107_ap_forecast_error_dist[3].split()[i]
ap_bin_range = f107_bin_range

# hist_f107 = np.array([ 0.02173913,  0.0621118 ,  0.20496894,  0.39751553,  0.1863354 ,   0.07763975,  0.0310559 ])
# hist_ap = np.array([ 0.04037267,  0.04968944,  0.1552795 ,  0.35093168,  0.20496894,  0.0931677 ,  0.02484472])

hist_f107 =  np.zeros([len(read_file_f107_ap_forecast_error_dist[4].split())])
for i in range(len(read_file_f107_ap_forecast_error_dist[4].split())):
    hist_f107[i] = read_file_f107_ap_forecast_error_dist[4].split()[i]

hist_ap =  np.zeros([len(read_file_f107_ap_forecast_error_dist[5].split())])
for i in range(len(read_file_f107_ap_forecast_error_dist[5].split())):
    hist_ap[i] = read_file_f107_ap_forecast_error_dist[5].split()[i]


hist_f107 = hist_f107 / sum(hist_f107)  # for some reason sum(hist_f107) ~ 0.95
hist_ap = hist_ap / sum(hist_ap) # for some reason sum(hist_ap) ~ 0.95


# f107_bin_range = np.array([-15.        , -10.71428571,  -6.42857143,  -2.14285714,         2.14285714,   6.42857143,  10.71428571,  15.        ])
# ap_bin_range = f107_bin_range

f107_bin_center = (f107_bin_range[:-1] + np.roll(f107_bin_range, -1)[:-1])/2
ap_bin_center = (ap_bin_range[:-1] + np.roll(ap_bin_range, -1)[:-1])/2
nb_f107 = len(f107_bin_center)
nb_ap = len(ap_bin_center)

# same as in deviation_swpc_f107_ap.py
f107_bin_center_same_as_filename = []
ap_bin_center_same_as_filename = []
for if107 in range(nb_f107):
    f107_bin_center_same_as_filename.append( np.float(format(f107_bin_center[if107], ".0f")) ) 
for iap in range(nb_ap):
    ap_bin_center_same_as_filename.append( np.float(format(ap_bin_center[iap], ".0f")) )
f107_bin_center_same_as_filename = np.array(f107_bin_center_same_as_filename) # [-13.,  -9.,  -4.,   0.,   4.,   9.,  13.]
ap_bin_center_same_as_filename = np.array(ap_bin_center_same_as_filename) # [-13.,  -9.,  -4.,   0.,   4.,   9.,  13.]

                      # [-13.,         -9.,          -4.,         0.,         4.,           9.,         13.]


# first look if static or actual runs are in the list. nb_run is only the runs where F10.7 and Ap have prediction errors
for irun in range(nb_run):
    run_name = read_file_results_pc[irun].split()[0]
    if  (('actual' in run_name) == True) :
        nb_run = nb_run - 1
if  (('static' in run_name) == True) :
    nb_run = nb_run - 1
pc_actual = -1
pc_static = -1
f107 = []
ap = []
density = []

list_run = []
pc_vs_f107_ap = np.zeros([7,7])
dca_vs_f107_ap = np.zeros([7,7])

for irun in range(len(read_file_results_pc)):
    # PC TCA DCA
    pc_irun = []
    run_name = read_file_results_pc[irun].split()[0]
    list_run.append(run_name)
    if  (( ('actual' in run_name) == False) & (('static' in run_name) == False)):
        f107.append( np.float(run_name.split('f107_')[1].split('_')[0]) )
        ap.append( np.float(run_name.split('ap_')[1].split('.')[0]) )
        pc_irun.append( np.float( read_file_results_pc[irun].split()[1] ) )
        tca.append( read_file_results_pc[irun].split()[2] )
        dca.append(np.float( read_file_results_pc[irun].split()[3] ))

        where_f107  = np.where(f107_bin_center_same_as_filename == f107[-1])[0][0]
        prob_f107 = hist_f107[where_f107]

        where_ap  = np.where(ap_bin_center_same_as_filename == ap[-1])[0][0]
        prob_ap = hist_ap[where_ap]

        pc_irun.append(prob_f107 * prob_ap)
        pc_irun.append(prob_f107)
        pc_irun.append(f107[-1])
        pc_irun.append(prob_ap)
        pc_irun.append(ap[-1])
        pc.append(pc_irun)
        
        f107_index = np.where(f107_bin_center_same_as_filename == f107[-1])[0][0]
        ap_index = np.where(ap_bin_center_same_as_filename == ap[-1])[0][0]
        pc_vs_f107_ap[ap_index, f107_index] = np.float( read_file_results_pc[irun].split()[1] ) 
        dca_vs_f107_ap[ap_index, f107_index] = np.float( read_file_results_pc[irun].split()[3] ) 
    elif ('actual' in run_name) == True: ## Pc calculated using the oserbved F10.7 and Ap ( no predictions, the F10.7 and Ap that end up occuring in reality)                                       
        pc_actual = np.float( read_file_results_pc[irun].split()[1] )
        tca_actual = read_file_results_pc[irun].split()[2] 
        dca_actual = np.float( read_file_results_pc[irun].split()[3] )
    elif ('static' in run_name) == True: ## Pc calculated using the static F10.7, F10.7A and Ap values reported in the VCM. These are those that CARA used to compute Pc. So this Pc is to compare to the PC computed by CADA (pc_cara)
        pc_static = np.float( read_file_results_pc[irun].split()[1] )
        tca_static = read_file_results_pc[irun].split()[2] 
        dca_static = np.float(read_file_results_pc[irun].split()[3] )



#     # DENSITY AP F107
#     input_filename =  run_name
#     print "mpiexec /home1/cbussy/spock_eq6_20171101_density_out " + run_name
#     #os.system("mpiexec /home1/cbussy/spock_eq6_20171101_density_out " + run_name)
#     var_in, var_in_order = read_input_file(input_filename)
#     output_file_path_list = var_in[find_in_read_input_order_variables(var_in_order, 'output_file_path_list')]; 
#     output_file_name_list = var_in[find_in_read_input_order_variables(var_in_order, 'output_file_name_list')];
#     nb_sc = 1# for density only plot the one for onee of the scvar_in[find_in_read_input_order_variables(var_in_order, 'nb_sc')];
#     nb_steps = var_in[find_in_read_input_order_variables(var_in_order, 'nb_steps')];
#     dt = var_in[find_in_read_input_order_variables(var_in_order, 'dt_output')];

#     nb_seconds_in_simu = ( nb_steps - 1 ) * dt
#     density_isc = []
#     nb_orbit_isc = []
#     isc = 0

#     var_to_read = ["latitude", "density", "ap", "f107"]
#     var_out, var_out_order = read_output_file( output_file_path_list[isc] + output_file_name_list[isc], var_to_read )

#     density_here = np.zeros([nb_sc, nb_steps]) # all output files of one simulation have the same number of steps
#     latitude = np.zeros([nb_sc, nb_steps]) # all output files of one simulation have the same number of steps
#     date = var_out[find_in_read_input_order_variables(var_out_order, 'date')]
    
#     density_here[isc, :nb_steps] = var_out[find_in_read_input_order_variables(var_out_order, 'density')]
#     latitude[isc, :nb_steps] = var_out[find_in_read_input_order_variables(var_out_order, 'latitude')]
#     ap.append( var_out[find_in_read_input_order_variables(var_out_order, 'ap')] )
#     f107.append( var_out[find_in_read_input_order_variables(var_out_order, 'f107')])
#     if irun == 0:
#         date_given_output = var_out[find_in_read_input_order_variables(var_out_order, 'date_given_output')]
#         nb_steps_given_output = len(date_given_output)
#         nb_seconds_since_start_for_given_output = np.zeros([nb_steps_given_output])
#         for istep_given in range(nb_steps_given_output):
#             date_given_output_datetime = datetime.strptime(date_given_output[istep_given],"%Y-%m-%dT%H:%M:%S.%f:") # 2016-11-26T00:00:10.000000:
#             nb_seconds_since_start_for_given_output[istep_given] = ( date_given_output_datetime - datetime.strptime(date[0], "%Y/%m/%d %H:%M:%S.%f") ).total_seconds() #'2016/11/26 00:00:00.000000'

#     density_orbit_averaged, time_averaged, index_time_averaged = orbit_average(density_here[isc, :nb_steps], latitude[isc, :nb_steps], date )
#     if (irun == 0): # assume the same times for the orbit for all runs. This is true within a few min at most so is an ok approximation
#         x_axis_average = []
#         nb_orbit_for_this_sc = len(time_averaged)
#         date_average_start_orbit_list = np.array(time_averaged)[:,0]  # take the date at the start of the bin
#         for iorbit in range(nb_orbit_for_this_sc):
#             date_average_start_orbit = date_average_start_orbit_list[iorbit]
#             date_average_start_orbit = datetime.strptime( date_average_start_orbit, "%Y/%m/%d %H:%M:%S.%f" )
#             nb_seconds_between_start_orbit_and_date_start = ( date_average_start_orbit - datetime.strptime(date[0], "%Y/%m/%d %H:%M:%S.%f") ).total_seconds()
#             x_axis_average.append( nb_seconds_between_start_orbit_and_date_start )
#         x_axis_average = np.array(x_axis_average)
#     density.append(density_orbit_averaged)

# density = np.array(density)
# density_average_time = np.mean(density, axis = 1)




# for if107 in range(nb_f107):
#     for iap in range(nb_ap):
        
file_results_pc.close()

# read pc cara from cdm. open any of the SpOCK main input files in filename_results_pc and read the cdm included in the main input file

file_run_name = open(run_name, "r")
read_file_run_name = file_run_name.readlines()
find_orbit = 0
while ( "#ORBIT" in read_file_run_name[find_orbit].split() ) == False:
    find_orbit = find_orbit + 1
cdm_filename = read_file_run_name[find_orbit+4].split()[0]
time_cdm = ' '.join(cdm_filename.split('_')[-2:]).replace(' ',  'T').replace('.cdm', '')
time_cdm_date = datetime.strptime(time_cdm, '%Y%m%dT%H%M%S' ) # 20171101T145854.cdm
cdm_file = open(cdm_filename)
read_cdm_file = cdm_file.readlines()
find_cara_pc = 0
while ( "COLLISION_PROBABILITY" in read_cdm_file[find_cara_pc].split() ) == False:
    find_cara_pc = find_cara_pc + 1
pc_cara = np.float(read_cdm_file[find_cara_pc].split()[2])
cdm_file.close()
file_run_name.close()


pc = np.array(pc) # pc[irun,:]:  0 pc, 1 probability of (f107,ap) to occur, 2 probablity of f107 to occur, 3 f107, 4 probablity of ap to occur, 5 ap
index_sort_pc = np.argsort(pc[:,0])
pc_sort = pc[index_sort_pc] # pc array sorted by increasing number of pc

index_sort_prob = np.argsort(pc[:,1])
pc_sort_on_prob = pc[index_sort_prob] # pc array sorted by increasing number of pc

#density_average_time_sorted = density_average_time[index_sort_prob]

nb_point_interpo_in_between_two_pc = 10
prob_interpolated = np.zeros([(nb_run-1) * nb_point_interpo_in_between_two_pc+1]) # +1 for the last run of pc_sort
pc_interpolated = np.zeros([(nb_run-1) * nb_point_interpo_in_between_two_pc+1])
for irun in range(nb_run-1):
    x1 = pc_sort[irun, 0]
    x2 = pc_sort[irun + 1, 0]
    y1 = pc_sort[irun, 1]
    y2 = pc_sort[irun + 1, 1]
    for iin in range(nb_point_interpo_in_between_two_pc):
        delta_y = y2 - y1
        delta_x = x2 - x1
        a = delta_y / delta_x
        b = y1 - a * x1        
        pc_interpolated[irun*nb_point_interpo_in_between_two_pc + iin] = x1 + delta_x / nb_point_interpo_in_between_two_pc * iin
        prob_interpolated[irun*nb_point_interpo_in_between_two_pc + iin] = a * pc_interpolated[irun*nb_point_interpo_in_between_two_pc + iin] + b
    
pc_interpolated[-1] = pc_sort[-1,0]
prob_interpolated[-1] = pc_sort[-1,1]


max_pc = np.max(pc_sort[:,0])
min_pc = np.min(pc_sort[:,0])#0#np.min(pc_sort[:,0])
bin_size_cdf = (max_pc - min_pc)/11#0.000010059604428625#0.00015059604428625#(max_pc - min_pc)/8#1e-4#(max_pc - min_pc)/10 #1.e-5
# if 'nov01_h14' in run_name:
#     bin_size_cdf = bin_size_cdf/10.#(max_pc - min_pc)/8#1e-4#(max_pc - min_pc)/10 #1.e-5
# if 'oct29_h06' in run_name:
#     bin_size_cdf = bin_size_cdf/10.#(max_pc - min_pc)/8#1e-4#(max_pc - min_pc)/10 #1.e-5
nb_bin_cdf = (int) ( ( max_pc - min_pc ) / bin_size_cdf )
cdf_per_bin  = np.zeros([nb_bin_cdf]) # probability of Pc to be in each bin (= for each bin, integral of 'probability VS Pc')
average_pc_per_bin  = np.zeros([nb_bin_cdf]) # probability of Pc to be in each bin (= for each bin, integral of 'probability VS Pc')
bin_cdf_array = np.zeros([nb_bin_cdf])
density_prob = np.zeros([nb_bin_cdf])
density_prob_with_interpo = np.zeros([nb_bin_cdf])
cumulative_density_prob = np.zeros([nb_bin_cdf])
#bin_min = min_pc
for ibin in range(nb_bin_cdf):
    bin_min = min_pc + ibin * bin_size_cdf#bin_min*5#min_pc + ibin * bin_size_cdf
    bin_max = min_pc + ( ibin + 1 ) * bin_size_cdf#bin_min*5#min_pc + ( ibin + 1 ) * bin_size_cdf
    #print bin_min, bin_max
    where_pc_in_bin = np.where( ( pc_interpolated >= bin_min ) & ( pc_interpolated < bin_max ) )[0]
    nb_pc_in_bin = len(where_pc_in_bin) # nb of runs with Pc in this bin    
    pc_in_bin = pc_interpolated[where_pc_in_bin] # pc_interpolated is already sorted in ascending order
    prob_in_bin = prob_interpolated[where_pc_in_bin]
    density_prob_with_interpo[ibin] = np.sum(prob_in_bin) #np.sum(pc_in_bin * prob_in_bin)

    where_pc_in_bin = np.where( ( pc_sort[:,0] >= bin_min ) & ( pc_sort[:,0] < bin_max ) )[0]
    prob_in_bin = pc_sort[where_pc_in_bin, 1]
    density_prob[ibin] = np.sum(prob_in_bin) #np.sum(pc_in_bin * prob_in_bin)
    cumulative_density_prob[ibin] = np.sum(density_prob[:ibin+1])
    bin_cdf_array[ibin] = bin_min 
    for ipc in range(nb_pc_in_bin-1):
        x1 = pc_interpolated[ipc]
        x2 = pc_interpolated[ipc+1]
        y1 = prob_interpolated[ipc]
        y2 = prob_interpolated[ipc+1]
        area = y1 * (x2 - x1) + (x2 - x1) * ( y2 - y1 ) / 2.
        cdf_per_bin[ibin] =  cdf_per_bin[ibin] + area
        average_pc_per_bin[ibin] = average_pc_per_bin[ibin] + prob_interpolated[ipc]
    average_pc_per_bin[ibin] = average_pc_per_bin[ibin] + prob_interpolated[nb_pc_in_bin-1]
    average_pc_per_bin[ibin] = average_pc_per_bin[ibin] / nb_pc_in_bin

cumulative_density_prob2 = np.zeros([len(pc_sort[:,0])])
for ipc in range(len(pc_sort[:,0])-1):
    cumulative_density_prob2[ipc] = np.sum(pc_sort[:ipc+1,1])
cumulative_density_prob2[-1] = cumulative_density_prob2[-2] + pc_sort[-1,1]
# FOR ZOOM PDF ON A PARTICUALR REGION: MAKE A PDF WITHIN THIS REGION
max_pc_zoom_pdf = 1e-4
min_pc_zoom_pdf = 0
bin_size_cdf_zoom_pdf = (max_pc_zoom_pdf - min_pc_zoom_pdf)/10#1e-4#(max_pc - min_pc)/10 #1.e-5
nb_bin_cdf_zoom_pdf = (int) ( ( max_pc_zoom_pdf - min_pc_zoom_pdf ) / bin_size_cdf_zoom_pdf )
bin_cdf_array_zoom_pdf = np.zeros([nb_bin_cdf_zoom_pdf])
density_prob_zoom_pdf = np.zeros([nb_bin_cdf_zoom_pdf])
density_prob_zoom_pdf_with_interpo = np.zeros([nb_bin_cdf_zoom_pdf])
cumulative_density_prob_zoom_pdf = np.zeros([nb_bin_cdf_zoom_pdf])
for ibin in range(nb_bin_cdf_zoom_pdf):
    bin_min = min_pc_zoom_pdf + ibin * bin_size_cdf_zoom_pdf
    bin_max = min_pc_zoom_pdf + ( ibin + 1 ) * bin_size_cdf_zoom_pdf
    where_pc_zoom_pdf_in_bin = np.where( ( pc_interpolated >= bin_min ) & ( pc_interpolated < bin_max ) )[0]
    nb_pc_in_bin = len(where_pc_in_bin) # nb of runs with Pc in this bin    
    pc_in_bin = pc_interpolated[where_pc_in_bin] # pc_interpolated is already sorted in ascending order
    prob_in_bin = prob_interpolated[where_pc_in_bin]
    density_prob_zoom_pdf_with_interpo[ibin] = np.sum(prob_in_bin) #np.sum(pc_in_bin * prob_in_bin)

    where_pc_in_bin = np.where( ( pc_sort[:,0] >= bin_min ) & ( pc_sort[:,0] < bin_max ) )[0]
    prob_in_bin = pc_sort[where_pc_in_bin, 1]
    density_prob_zoom_pdf[ibin] = np.sum(prob_in_bin) #np.sum(pc_in_bin * prob_in_bin)
    cumulative_density_prob_zoom_pdf[ibin] = np.sum(density_prob_zoom_pdf[:ibin+1])
    bin_cdf_array_zoom_pdf[ibin] = bin_min 

print 'Plotting...'
# PLOTS
## Parameters for the figure
height_fig = 11.  # the width is calculated as height_fig * 4/3.
fontsize_plot = 29
ratio_fig_size = 4./3
width_fig = 25
### For plots, generate disctinct colors
NCURVES = len(hist_f107)
np.random.seed(101)
curves = [np.random.random(20) for i in range(NCURVES)]
values = range(NCURVES)
jet = cm = plt.get_cmap('jet') 
cNorm  = colors.Normalize(vmin=0, vmax=values[-1])
scalarMap = cmx.ScalarMappable(norm=cNorm, cmap=jet)



## densityof probbiliy and CDF
fig_title = ''#Probability per $P_C$ bin'
fig = plt.figure(num=None, figsize=(width_fig, height_fig), dpi=80, facecolor='w', edgecolor='k')
fig.suptitle(fig_title, y = 0.965,fontsize = (int)(fontsize_plot*1.1), weight = 'bold',)
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
gs = gridspec.GridSpec(1, 2)
gs.update(left = 0.11, right=0.87, top = 0.93,bottom = 0.12, hspace = 0.01)

ax_pdf = fig.add_subplot(gs[0, 0])
y_label = 'Probability (%)'
x_label = '$P_C$'

ax_pdf.set_ylabel(y_label, weight = 'bold', fontsize  = fontsize_plot)
ax_pdf.set_xlabel(x_label, weight = 'bold', fontsize  = fontsize_plot)

[i.set_linewidth(2) for i in ax_pdf.spines.itervalues()] # change the width of the frame of the figure
ax_pdf.tick_params(axis='both', which='major', labelsize=fontsize_plot, size = 10, width = 2, pad = 7) 
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
 
#hist_pdf = ax_pdf.hist(pc_sort[:, 0])[0] / nb_run * 100
ax_pdf.bar(bin_cdf_array, density_prob*100., bin_size_cdf, 0 , linewidth = 2, align = 'edge', alpha = 0.9)

#ax_pdf.bar(bin_cdf_array[:-1], density_prob[:-1]*100., bin_cdf_array[1:] - bin_cdf_array[:-1])#, bin_size_cdf, 0 , linewidth = 2, align = 'edge')


#nominal Pc (ie run for which error in f107 and ap are 0, ie run using the predictions of 107 and ap by SWPC  )
nominal_run = np.where((pc_sort[:,3] == 0 ) & (pc_sort[:,5] == 0))[0][0] 
pc_nominal = pc_sort[nominal_run, 0]
ax_pdf.plot([pc_nominal, pc_nominal], [0, pc_sort[nominal_run, 1]*100], linewidth = 4, color = 'blue')
ax_pdf.text(pc_nominal, pc_sort[nominal_run, 1]*100+0.5, 'Nominal', fontsize = fontsize_plot, weight = 'bold', horizontalalignment = 'center', verticalalignment = 'bottom', rotation = 90, color = 'blue')

ax_pdf.margins(0,0)
ymin_axis = ax_pdf.get_ylim()[0]
ymax_axis = ax_pdf.get_ylim()[1]
deltay = ymax_axis - ymin_axis
# Pc calculated by CARA
ax_pdf.scatter([pc_cara, pc_cara], [ymin_axis+deltay/100, ymin_axis+deltay/100], marker = 'o', color = 'k',s = 130, zorder = 5)
ax_pdf.text(pc_cara, ymin_axis+deltay/100+1.65*deltay/100, 'CARA', fontsize = fontsize_plot, weight = 'bold', horizontalalignment = 'center', verticalalignment = 'bottom', rotation = 90, color = 'k')

# Pc calculated using the oserbved F10.7 and Ap ( no predictions, the F10.7 and Ap that end up occuring in reality)
if pc_actual != -1:
    ax_pdf.scatter([pc_actual, pc_actual], [ymin_axis+deltay/100, ymin_axis+deltay/100], marker = 'o', color = 'magenta',s = 130, zorder = 5)
    ax_pdf.text(pc_actual, ymin_axis+deltay/100+1.65*deltay/100, 'Actual', fontsize = fontsize_plot, weight = 'bold', horizontalalignment = 'center', verticalalignment = 'bottom', rotation = 90, color = 'magenta')

#Pc calculated using the static F10.7, F10.7A and Ap values reported in the VCM. These are those that CARA used to compute Pc. So this Pc is to compare to the PC computed by CADA (pc_cara)
if pc_static != -1:
    ax_pdf.scatter([pc_static, pc_static], [0.25, 0.25], marker = 'D', color = 'limegreen',s = 65, zorder = 5)
    ax_pdf.text(pc_static, 0.8, 'Static', fontsize = fontsize_plot, weight = 'bold', horizontalalignment = 'center', verticalalignment = 'bottom', rotation = 90, color = 'limegreen')

maneuver_time = '2017-11-01T03:00:00'
maneuver_time = datetime.strptime(maneuver_time, "%Y-%m-%dT%H:%M:%S")
days_to_tca = (tca_for_f107_ap_date - time_cdm_date).total_seconds() / 3600. / 24
hours_to_man = (maneuver_time - time_cdm_date).total_seconds() / 3600.
ax_pdf.text(0.95, 0.96, 'Days to TCA: ' +  format(days_to_tca, ".1f"), fontsize = fontsize_plot, weight = 'bold', transform = ax_pdf.transAxes, horizontalalignment = 'right', verticalalignment = 'top')
if hours_to_man < 0:
    ax_pdf.text(0.95, 0.91, 'Hours since maneuver: ' +  format(np.abs(hours_to_man), ".0f"), fontsize = fontsize_plot, weight = 'bold', transform = ax_pdf.transAxes, horizontalalignment = 'right', verticalalignment = 'top')
else:
    ax_pdf.text(0.95, 0.91, 'Hours until maneuver: ' +  format(np.abs(hours_to_man), ".0f"), fontsize = fontsize_plot, weight = 'bold', transform = ax_pdf.transAxes, horizontalalignment = 'right', verticalalignment = 'top')
ax_pdf.text(0.95, 0.83, '$\mathbf{P_{C, max}}$: ' +  format(np.max(pc_sort[:,0]), ".2e"), fontsize = fontsize_plot, weight = 'bold', transform = ax_pdf.transAxes, horizontalalignment = 'right', verticalalignment = 'top')
ax_pdf.text(0.95, 0.78, '$\mathbf{P_{C, min}}$: ' +  format(np.min(pc_sort[:,0]), ".2e"), fontsize = fontsize_plot, weight = 'bold', transform = ax_pdf.transAxes, horizontalalignment = 'right', verticalalignment = 'top')
pc_weighed_average = np.sum(pc[:,0]*pc[:,1])#/sum(pc[:,1])
ax_pdf.text(0.95, 0.73, '$\mathbf{P_{C, mean}}$: ' +  format(pc_weighed_average, ".2e"), fontsize = fontsize_plot, weight = 'bold', transform = ax_pdf.transAxes, horizontalalignment = 'right', verticalalignment = 'top')


#ax_pdf.get_xlim()[1]
#if np.max(pc[:,0]) < 1e-3:
ax_pdf.ticklabel_format(style = 'sci', axis = 'x', scilimits=(0,0))
ax_pdf.xaxis.offsetText.set_fontsize(24)

#ax_pdf.set_xlim([0, ax_pdf.get_xlim()[1]])
# if 'nov01_h14' in run_name:
#     ax_pdf.set_xlim([0, 2.1e-4])
# elif 'oct29_h06' in run_name:
#     ax_pdf.set_xlim([0, 2.1e-4])
# else:
#     ax_pdf.set_xlim([0, 2.1e-3])

# ax_pdf.set_ylim([0, 90])
# pc[irun,:]:  0 pc, 1 probability of (f107,ap) to occur, 2 probablity of f107 to occur, 3 f107, 4 probablity of ap to occur, 5 ap

## CDF
y_label = 'CDF (%)'
x_label = '$P_C$'
ax_cdf = fig.add_subplot(gs[0, 1])
ax_cdf.set_ylabel(y_label, weight = 'bold', fontsize  = fontsize_plot)
ax_cdf.set_xlabel(x_label, weight = 'bold', fontsize  = fontsize_plot)
[i.set_linewidth(2) for i in ax_cdf.spines.itervalues()] # change the width of the frame of the figure
ax_cdf.tick_params(axis='both', which='major', labelsize=fontsize_plot, size = 10, width = 2, pad = 7) 
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
#hist_pdf = ax_cdf.hist(pc_sort[:, 0])[0] / nb_run * 100
#ax_cdf.plot(bin_cdf_array, cumulative_density_prob/cumulative_density_prob[-1]*100, linewidth = 3, color = 'b') 
ax_cdf.semilogx(pc_sort[:,0], cumulative_density_prob2*100, linewidth = 3, color = 'r') 
ax_cdf.margins(0,0)
ax_cdf.set_ylim([0, 105])
ax_cdf.set_xlim([4e-9, 2.2e-3])

#ax_cdf.ticklabel_format(style = 'sci', axis = 'x', scilimits=(0,0))
#ax_cdf.xaxis.offsetText.set_fontsize(24)

# pc[irun,:]:  0 pc, 1 probability of (f107,ap) to occur, 2 probablity of f107 to occur, 3 f107, 4 probablity of ap to occur, 5 ap

fig_save_name = filename_results_pc.replace(".txt", '_pdf_and_cdf_pc.png')
fig.set_figheight(height_fig)
fig.set_figwidth(width_fig)

fig.savefig(fig_save_name, facecolor=fig.get_facecolor(), edgecolor='none', bbox_inches='tight')  
#os.system("scp -p "  + fig_save_name + " desk:")

fig_save_name = filename_results_pc.replace(".txt", '_pdf_and_cdf_pc.pdf')
fig.set_figheight(height_fig)
fig.set_figwidth(width_fig)

fig.savefig(fig_save_name, facecolor=fig.get_facecolor(), edgecolor='none', bbox_inches='tight')  
#os.system("scp -p "  + fig_save_name + " desk:")

if show_plot == 1:
    plt.show(); plt.show()





#Contour of Pc as a function of f107 and Ap forecast error

fig_title = ''
y_label = '$\mathbf{\Delta}$Ap'
x_label = '$\mathbf{\Delta}$F10.7'
fig = plt.figure(num=None, figsize=(height_fig * ratio_fig_size, height_fig), dpi=80, facecolor='w', edgecolor='k')
fig.suptitle(fig_title, y = 0.96,fontsize = (int)(fontsize_plot*1.1), weight = 'bold',)
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
gs = gridspec.GridSpec(1, 1)
gs.update(left = 0.11, right=0.87, top = 0.93,bottom = 0.12, hspace = 0.01)
ax = fig.add_subplot(gs[0, 0])

ax.set_ylabel(y_label, weight = 'bold', fontsize  = fontsize_plot)
ax.set_xlabel(x_label, weight = 'bold', fontsize  = fontsize_plot)


[i.set_linewidth(2) for i in ax.spines.itervalues()] # change the width of the frame of the figure
ax.tick_params(axis='both', which='major', labelsize=fontsize_plot, size = 10, width = 2, pad = 7) 
plt.rc('font', weight='bold') ## make the labels of the ticks in bold

x = ap_bin_center_same_as_filename
y = f107_bin_center_same_as_filename

X, Y = np.meshgrid(x, y)
Z = np.log10(pc_vs_f107_ap) #np.log10(pc_vs_f107_ap)#pc_vs_f107_ap
infvalue = np.where(np.isinf(np.log10(pc_vs_f107_ap)) == True)
noinfvalue = np.where(np.isinf(np.log10(pc_vs_f107_ap)) == False)
max_p = np.max(Z[noinfvalue[0], noinfvalue[1]])
min_p = np.min(Z[noinfvalue[0], noinfvalue[1]])
Znoinf = Z
dlev = 0.5
#levels = np.arange(min_p, max_p+dlev, dlev)
print min_p, max_p
min_try = np.log10(5*10**-7)
if 'oct31' in run_name:
    levels = np.arange(-6.5,-2.5+dlev,dlev)
    s = 10**levels
    ticklabel = []
    for i in range(len(s)):
        ticklabel.append(format(s[i], ".0e"))

elif 'oct29' in run_name:
    levels = np.arange(-7,-3+dlev,dlev)
    s = 10**levels
    ticklabel = []
    for i in range(len(s)):
        ticklabel.append(format(s[i], ".0e"))

elif 'nov01_h14' in run_name: # linear scale since Pc varies a much less wide range than oct29 and oct31 cases so log looks ugly
    Z = pc_vs_f107_ap
    #leave block below _ doesnt matter much but for consistency for lines under it (ouside of if)
    infvalue = np.where(np.isinf(np.log10(pc_vs_f107_ap)) == True)
    noinfvalue = np.where(np.isinf(np.log10(pc_vs_f107_ap)) == False)
    max_p = np.max(Z[noinfvalue[0], noinfvalue[1]])
    min_p = np.min(Z[noinfvalue[0], noinfvalue[1]])
    print min_p, max_p
    Znoinf = Z
    # end of leave block below _ doesnt matter much but for consistency for lines under it (ouside of if)
    dlev = 0.5
    maxcontour = 2e-4
    mincontour = 1e-7
    nlev = 10
    dcontour = 2e-5
    levels = np.arange(mincontour,maxcontour+dcontour,dcontour)
    s = levels
    ticklabel = []
    for i in range(len(s)):
        ticklabel.append(format(s[i], ".1e"))

else:
    print "***! You need to chose the levels of the contour plot Pc VS F10.7/Ap. The program will stop. !***"; raise Exception

Znoinf[infvalue[0], infvalue[1]] = np.min(levels) - 1
nr, nc = Z.shape

Z = np.ma.array(Znoinf)


# levels_lin = [1,3, 7, 12, 18,25,35,45,60, 80, 110, 150, 210,280, 360] #np.arange(1,365+10,20)
nlevels = 10
#levels  = np.arange(np.min(pc[:,0]), np.max(pc[:,0]), (np.max(pc[:,0]) - )
origin = 'upper'
# CS1 = ax.contourf(X, Y, Z, 10,#levels,
#                   #[-1, -0.1, 0, 0.1],
#                   #alpha=0.5,
#                   #                      locator=ticker.LogLocator(),
#                   #norm = LogNorm(),
#                   cmap = plt.cm.get_cmap("rainbow"),
#                   origin=origin)

CS1 = ax.contourf(X, Y, Z, levels,
                  #[-1, -0.1, 0, 0.1],
                  #alpha=0.5,
                  #                      locator=ticker.LogLocator(),
                  #norm = LogNorm(),
                  cmap = plt.cm.get_cmap("rainbow"),
                  origin=origin,
                  extend = "min")
CS1.cmap.set_under('darkslateblue')
#CS1.cmap.set_over('cyan')
#cs.set_clim(50, 210)

fmt = matplotlib.ticker.FormatStrFormatter("%g")
cbar = plt.colorbar(CS1, ax = ax, ticks = levels, format = fmt)
cbar.ax.set_ylabel('$\mathbf{P_C}$', fontsize = fontsize_plot, weight = 'bold', rotation = -90,labelpad =30)
cbar.ax.tick_params(labelsize=fontsize_plot) 
#ticklabel = np.array2string(s, formatter={'float_kind':lambda s: "%.0e" % s})
cbar.ax.set_yticklabels(ticklabel)

fig_save_name = filename_results_pc.replace(".txt", '_pc_contour.png')
fig.set_figheight(height_fig)
fig.set_figwidth(width_fig)

fig_save_name = filename_results_pc.replace(".txt", '_pc_contour.pdf')
fig.set_figheight(height_fig)
fig.set_figwidth(width_fig)

fig.savefig(fig_save_name, facecolor=fig.get_facecolor(), edgecolor='none', bbox_inches='tight')  
#os.system("scp -p "  + fig_save_name + " desk:")

if show_plot == 1:
    plt.show(); plt.show()



#Contour of Dca as a function of f107 and Ap forecast error
iarea = 1
fig_title = ''
y_label = '$\mathbf{\Delta}$Ap'
x_label = '$\mathbf{\Delta}$F10.7'
fig = plt.figure(num=None, figsize=(height_fig * ratio_fig_size, height_fig), dpi=80, facecolor='w', edgecolor='k')
fig.suptitle(fig_title, y = 0.96,fontsize = (int)(fontsize_plot*1.1), weight = 'bold',)
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
gs = gridspec.GridSpec(1, 1)
gs.update(left = 0.11, right=0.87, top = 0.93,bottom = 0.12, hspace = 0.01)
ax = fig.add_subplot(gs[0, 0])

ax.set_ylabel(y_label, weight = 'bold', fontsize  = fontsize_plot)
ax.set_xlabel(x_label, weight = 'bold', fontsize  = fontsize_plot)


[i.set_linewidth(2) for i in ax.spines.itervalues()] # change the width of the frame of the figure
ax.tick_params(axis='both', which='major', labelsize=fontsize_plot, size = 10, width = 2, pad = 7) 
plt.rc('font', weight='bold') ## make the labels of the ticks in bold

x = ap_bin_center_same_as_filename
y = f107_bin_center_same_as_filename

X, Y = np.meshgrid(x, y)
Z = dca_vs_f107_ap


nr, nc = Z.shape

Z = np.ma.array(Z)


# levels_lin = [1,3, 7, 12, 18,25,35,45,60, 80, 110, 150, 210,280, 360] #np.arange(1,365+10,20)
nlevels = 10
#levels  = np.arange(np.min(dca[:,0]), np.max(dca[:,0]), (np.max(dca[:,0]) - )
origin = 'lower'
CS1 = ax.contourf(X, Y, Z, 10,#levels,
                  #[-1, -0.1, 0, 0.1],
                  #alpha=0.5,
                  #                      locator=ticker.LogLocator(),
                  #norm = LogNorm(),
                  cmap = plt.cm.get_cmap("rainbow"),
                  origin=origin)

fmt = matplotlib.ticker.FormatStrFormatter("%g")
cbar = plt.colorbar(CS1, ax = ax)#, ticks = levels, format = fmt)
cbar.ax.set_ylabel('Miss distance (m)', fontsize = fontsize_plot, weight = 'bold', rotation = -90,labelpad =20)
cbar.ax.tick_params(labelsize=fontsize_plot) 


fig_save_name = filename_results_pc.replace(".txt", '_dca_contour.png')
fig.set_figheight(height_fig)
fig.set_figwidth(width_fig)

fig_save_name = filename_results_pc.replace(".txt", '_dca_contour.pdf')
fig.set_figheight(height_fig)
fig.set_figwidth(width_fig)

fig.savefig(fig_save_name, facecolor=fig.get_facecolor(), edgecolor='none', bbox_inches='tight')  
#os.system("scp -p "  + fig_save_name + " desk:")

if show_plot == 1:
    plt.show(); plt.show()










## Pc as a function of DCA (miss distance)
fig_title = ''#Probability per $P_C$ bin'
fig = plt.figure(num=None, figsize=(width_fig, height_fig), dpi=80, facecolor='w', edgecolor='k')
fig.suptitle(fig_title, y = 0.965,fontsize = (int)(fontsize_plot*1.1), weight = 'bold',)
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
gs = gridspec.GridSpec(1, 2)
gs.update(left = 0.11, right=0.87, top = 0.93,bottom = 0.12, hspace = 0.01)

ax_pdf = fig.add_subplot(gs[0, 0])

y_label = '$P_C$'
x_label = 'Miss distance (m)'

ax_pdf.set_ylabel(y_label, weight = 'bold', fontsize  = fontsize_plot)
ax_pdf.set_xlabel(x_label, weight = 'bold', fontsize  = fontsize_plot)

[i.set_linewidth(2) for i in ax_pdf.spines.itervalues()] # change the width of the frame of the figure
ax_pdf.tick_params(axis='both', which='major', labelsize=fontsize_plot, size = 10, width = 2, pad = 7) 
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
 
ax_pdf.scatter(dca, pc[:, 0], linewidth = 4, color = 'r')
ax_pdf.margins(0,0)
ax_pdf.set_ylim([np.min(pc[:, 0]), np.max(pc[:, 0])])
ax_pdf.set_xlim([np.min(dca), np.max(dca)])
# pc[irun,:]:  0 pc, 1 probability of (f107,ap) to occur, 2 probablity of f107 to occur, 3 f107, 4 probablity of ap to occur, 5 ap

fig_save_name = filename_results_pc.replace(".txt", '_pc_vs_miss_distance.png')
fig.set_figheight(height_fig)
fig.set_figwidth(width_fig)

fig_save_name = filename_results_pc.replace(".txt", '_pc_vs_miss_distance.pdf')
fig.set_figheight(height_fig)
fig.set_figwidth(width_fig)

fig.savefig(fig_save_name, facecolor=fig.get_facecolor(), edgecolor='none', bbox_inches='tight')  
#os.system("scp -p "  + fig_save_name + " desk:")

if show_plot == 1:
    plt.show(); plt.show()


raise Exception



## Pc as a function of atmospehric density
fig_title = ''#Probability per $P_C$ bin'
fig = plt.figure(num=None, figsize=(width_fig, height_fig), dpi=80, facecolor='w', edgecolor='k')
fig.suptitle(fig_title, y = 0.965,fontsize = (int)(fontsize_plot*1.1), weight = 'bold',)
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
gs = gridspec.GridSpec(1, 2)
gs.update(left = 0.11, right=0.87, top = 0.93,bottom = 0.12, hspace = 0.01)

ax_pdf = fig.add_subplot(gs[0, 0])

y_label = '$P_C$'
x_label = 'Average density (km/m$^3$)'

ax_pdf.set_ylabel(y_label, weight = 'bold', fontsize  = fontsize_plot)
ax_pdf.set_xlabel(x_label, weight = 'bold', fontsize  = fontsize_plot)

[i.set_linewidth(2) for i in ax_pdf.spines.itervalues()] # change the width of the frame of the figure
ax_pdf.tick_params(axis='both', which='major', labelsize=fontsize_plot, size = 10, width = 2, pad = 7) 
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
 
ax_pdf.scatter(density_average_time, pc[:, 0], linewidth = 4, color = 'r')
ax_pdf.margins(0,0)
ax_pdf.set_ylim([np.min(pc[:, 0]), np.max(pc[:, 0])])
ax_pdf.set_xlim([np.min(density_average_time), np.max(density_average_time)])
# pc[irun,:]:  0 pc, 1 probability of (f107,ap) to occur, 2 probablity of f107 to occur, 3 f107, 4 probablity of ap to occur, 5 ap

fig_save_name = filename_results_pc.replace(".txt", '_pc_vs_rho.png')
fig.set_figheight(height_fig)
fig.set_figwidth(width_fig)

fig.savefig(fig_save_name, facecolor=fig.get_facecolor(), edgecolor='none', bbox_inches='tight')  
os.system("scp -p "  + fig_save_name + " desk:")

if show_plot == 1:
    plt.show(); plt.show()



# all density scenarios
fig_title = ''
y_label = 'Density (kg/m$^3$)'
x_label = 'Real time'
fig = plt.figure(num=None, figsize=(height_fig * ratio_fig_size, height_fig), dpi=80, facecolor='w', edgecolor='k')
fig.suptitle(fig_title, y = 0.965,fontsize = (int)(fontsize_plot*1.1), weight = 'bold',)
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
gs = gridspec.GridSpec(1, 1)
gs.update(left = 0.11, right=0.87, top = 0.93,bottom = 0.12, hspace = 0.01)
ax = fig.add_subplot(gs[0, 0])

ax.set_ylabel(y_label, weight = 'bold', fontsize  = fontsize_plot)
ax.set_xlabel(x_label, weight = 'bold', fontsize  = fontsize_plot)

[i.set_linewidth(2) for i in ax.spines.itervalues()] # change the width of the frame of the figure
ax.tick_params(axis='both', which='major', labelsize=fontsize_plot, size = 10, width = 2, pad = 7) 
plt.rc('font', weight='bold') ## make the labels of the ticks in bold

max_y = 0
min_y = 10000000000000000000
for irun in range(nb_run):
    print irun 
    run_name = list_run[irun]
    colorVal = scalarMap.to_rgba(irun)
    ax.plot(x_axis_average, density[irun, :], linewidth = 2, color = 'cornflowerblue')#colorVal)#, label = run_name.split('density_')[1].split('_')[0]) # run_name.split('ap_')[1].split('.')[0]

    if np.max(density[irun, :]) > max_y:
        max_y = np.max(density[irun, :])
    if np.min(density[irun, :]) < min_y:
        min_y = np.min(density[irun, :])

    if irun == 0:
        # x axis label is in real time
        ## all output files of one simulation have the same number of steps, and start at the same date
        nb_ticks_xlabel = 3
        dt_xlabel =  nb_seconds_in_simu / nb_ticks_xlabel # dt for ticks on x axis (in seconds)
        xticks = np.arange(0, nb_seconds_in_simu+1, dt_xlabel)
        date_ref = datetime.strptime(date[0], "%Y/%m/%d %H:%M:%S.%f")
        date_list_str = []
        date_list = [date_ref + timedelta(seconds=x-xticks[0]) for x in xticks]
        for i in range(len(xticks)):
            if dt_xlabel >= 3*24*3600:
                date_list_str.append( str(date_list[i])[5:10] )
            else:
                date_list_str.append( str(date_list[i])[5:10] + "\n(day + " + str((int)(xticks[i]/3600./24)) + ')' )
        ax.xaxis.set_ticks(xticks)
        ax.xaxis.set_ticklabels(date_list_str, fontsize = fontsize_plot)#, rotation='vertical')

ax.set_xlim([min(xticks), max(xticks)])
ax.set_ylim([min_y, max_y])
ax.margins(0,0);

#     legend = ax.legend(loc='center left', bbox_to_anchor=(1, 0.5), numpoints = 1,  title="Bin value", fontsize = fontsize_plot)
#     legend.get_title().set_fontsize(str(fontsize_plot))

fig_save_name = 'density' 
fig_save_name =  fig_save_name + '.pdf'
fig.savefig(fig_save_name, facecolor=fig.get_facecolor(), edgecolor='none', bbox_inches='tight')  





raise Exception
## densityof probbiliy and CDF
fig_title = ''#Probability per $P_C$ bin'
fig = plt.figure(num=None, figsize=(width_fig, height_fig), dpi=80, facecolor='w', edgecolor='k')
fig.suptitle(fig_title, y = 0.965,fontsize = (int)(fontsize_plot*1.1), weight = 'bold',)
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
gs = gridspec.GridSpec(1, 2)
gs.update(left = 0.11, right=0.87, top = 0.93,bottom = 0.12, hspace = 0.01)

ax_pdf = fig.add_subplot(gs[0, 0])
y_label = 'Probability (%)'
x_label = '$P_C$'

ax_pdf.set_ylabel(y_label, weight = 'bold', fontsize  = fontsize_plot)
ax_pdf.set_xlabel(x_label, weight = 'bold', fontsize  = fontsize_plot)

[i.set_linewidth(2) for i in ax_pdf.spines.itervalues()] # change the width of the frame of the figure
ax_pdf.tick_params(axis='both', which='major', labelsize=fontsize_plot, size = 10, width = 2, pad = 7) 
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
 
#hist_pdf = ax_pdf.hist(pc_sort[:, 0])[0] / nb_run * 100
ax_pdf.bar(bin_cdf_array_zoom_pdf, density_prob_zoom_pdf*100., bin_size_cdf_zoom_pdf, 0 , linewidth = 2, align = 'edge')

# # nominal Pc (ie run for which error in f107 and ap are 0, ie run using the predictions of 107 and ap by SWPC  )
# nominal_run = np.where((pc_sort[:,3] == 0 ) & (pc_sort[:,5] == 0))[0][0] 
# ax_pdf.plot([pc_sort[nominal_run, 0], pc_sort[nominal_run, 0]], [0, pc_sort[nominal_run, 1]*100], linewidth = 4, color = 'r')

# # Pc calculated byC ARA
# ax_pdf.scatter([pc_cara, pc_cara], [0.2, 0.2], marker = 'o', color = 'limegreen',s = 100, zorder = 5)

# # Pc calculated using the oserbved F10.7 and Ap ( no predictions, the F10.7 and Ap that end up occuring in reality)
# ax_pdf.scatter([pc_actual, pc_actual], [0.2, 0.2], marker = 'o', color = 'red',s = 100, zorder = 5)

# #Pc calculated using the static F10.7, F10.7A and Ap values reported in the VCM. These are those that CARA used to compute Pc. So this Pc is to compare to the PC computed by CADA (pc_cara)
# ax_pdf.scatter([pc_static, pc_static], [0.2, 0.2], marker = 'o', color = 'magenta',s = 100, zorder = 5)


ax_pdf.margins(0,0)
#ax_pdf.get_xlim()[1]
#ax_pdf.set_xlim([0, ax_pdf.get_xlim()[1]])


fig_save_name = 'pdf_pc_zoom'  
fig_save_name =  fig_save_name + '.png'
fig.set_figheight(height_fig)
fig.set_figwidth(width_fig)

fig.savefig(fig_save_name, facecolor=fig.get_facecolor(), edgecolor='none', bbox_inches='tight')  
os.system("scp -p "  + fig_save_name + " desk:")

if show_plot == 1:
    plt.show(); plt.show()


raise Exception


## Probability of Pc ocurring as a funcitno of Pc
fig_title = 'Probability of scenario (F10.7/Ap) VS $P_C$ for this scenario'
y_label = 'Probability (%)'
x_label = '$P_C$'
fig = plt.figure(num=None, figsize=(height_fig * ratio_fig_size, height_fig), dpi=80, facecolor='w', edgecolor='k')
fig.suptitle(fig_title, y = 0.98,fontsize = (int)(fontsize_plot*1.1), weight = 'bold',)
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
gs = gridspec.GridSpec(1, 1)
gs.update(left = 0.11, right=0.87, top = 0.93,bottom = 0.12, hspace = 0.01)
ax = fig.add_subplot(gs[0, 0])

ax.set_ylabel(y_label, weight = 'bold', fontsize  = fontsize_plot)
ax.set_xlabel(x_label, weight = 'bold', fontsize  = fontsize_plot)

[i.set_linewidth(2) for i in ax.spines.itervalues()] # change the width of the frame of the figure
ax.tick_params(axis='both', which='major', labelsize=fontsize_plot, size = 10, width = 2, pad = 7) 
plt.rc('font', weight='bold') ## make the labels of the ticks in bold

#ax.plot(pc_sort[:, 0], pc_sort[:, 1] , linewidth = 2, color = 'k')
ax.scatter(pc_sort[:, 0], pc_sort[:, 1]*100 , linewidth = 2, color = 'b')
for irun in range(nb_run):
    if  ( ( pc_sort[irun, 1]*100 < 0.1 ) | ( pc_sort[irun, 1]*100 > 6 ) ):
        ax.text(pc_sort[irun, 0], pc_sort[irun, 1]*100, str(pc_sort[irun, 3]) + ', ' + str( pc_sort[irun, 5]), 
                weight = 'bold', fontsize = fontsize_plot/1.2, horizontalalignment = 'center', verticalalignment = 'bottom', color =  'r')

for ibin in range(nb_bin_cdf):
    bin_min = min_pc + ibin * bin_size_cdf
    bin_max = min_pc + ( ibin + 1 ) * bin_size_cdf
    where_pc_in_bin = np.where( ( pc_interpolated >= bin_min ) & ( pc_interpolated < bin_max ) )[0]
    if len(where_pc_in_bin) > 0:
        nb_pc_in_bin = len(where_pc_in_bin) # nb of runs with Pc in this bin    
        pc_in_bin = pc_interpolated[where_pc_in_bin] # pc_interpolated is already sorted in ascending order
        prob_in_bin = prob_interpolated[where_pc_in_bin]
        ax.plot([pc_in_bin[0], pc_in_bin[0]], [0, prob_in_bin[0]*100], color = 'k', linewidth = 2, linestyle = 'dotted')
ax.plot(pc_interpolated, prob_interpolated*100, linewidth = 2, color = 'b')
ax.set_xlim([np.min(pc_sort[:, 0]), np.max(pc_sort[:, 0])])

# hist_pdf = ax.hist(pc_sort[:, 0])[0] / nb_run * 100
ax.set_ylim([0, np.max(pc[:,1])*100])
ax.set_xlim([min_pc, max_pc-bin_size_cdf])
ax.margins(0,0)
# pc[irun,:]:  0 pc, 1 probability of (f107,ap) to occur, 2 probablity of f107 to occur, 3 f107, 4 probablity of ap to occur, 5 ap

fig_save_name = 'probability_vs_pc'  
fig_save_name =  fig_save_name + '.pdf'
fig.savefig(fig_save_name, facecolor=fig.get_facecolor(), edgecolor='none', bbox_inches='tight')  





## Probability of F10.7 to occur
fig_title = 'Probability of F10.7 scenario to occur'
y_label = 'Probability (%)'
x_label = 'F10.7'
fig = plt.figure(num=None, figsize=(height_fig * ratio_fig_size, height_fig), dpi=80, facecolor='w', edgecolor='k')
fig.suptitle(fig_title, y = 0.965,fontsize = (int)(fontsize_plot*1.1), weight = 'bold',)
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
gs = gridspec.GridSpec(1, 1)
gs.update(left = 0.11, right=0.87, top = 0.93,bottom = 0.12, hspace = 0.01)
ax = fig.add_subplot(gs[0, 0])

ax.set_ylabel(y_label, weight = 'bold', fontsize  = fontsize_plot)
ax.set_xlabel(x_label, weight = 'bold', fontsize  = fontsize_plot)

[i.set_linewidth(2) for i in ax.spines.itervalues()] # change the width of the frame of the figure
ax.tick_params(axis='both', which='major', labelsize=fontsize_plot, size = 10, width = 2, pad = 7) 
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
 

bar_f107 = ax.bar(f107_bin_center, hist_f107*100., f107_bin_center[1] - f107_bin_center[0], 0 , linewidth = 2)
nb_bar = len(bar_f107)
for ibar in range(nb_bar):
    colorVal = scalarMap.to_rgba(ibar)
    bar_f107[ibar].set_color(colorVal)

ax.margins(0,0)

fig_save_name = 'f107_probability'  
fig_save_name =  fig_save_name + '.pdf'
fig.savefig(fig_save_name, facecolor=fig.get_facecolor(), edgecolor='none', bbox_inches='tight')  



## Probability of Ap to occur
fig_title = 'Probability of Ap scenario to occur'
y_label = 'Probability (%)'
x_label = 'Ap'
fig = plt.figure(num=None, figsize=(height_fig * ratio_fig_size, height_fig), dpi=80, facecolor='w', edgecolor='k')
fig.suptitle(fig_title, y = 0.965,fontsize = (int)(fontsize_plot*1.1), weight = 'bold',)
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
gs = gridspec.GridSpec(1, 1)
gs.update(left = 0.11, right=0.87, top = 0.93,bottom = 0.12, hspace = 0.01)
ax = fig.add_subplot(gs[0, 0])

ax.set_ylabel(y_label, weight = 'bold', fontsize  = fontsize_plot)
ax.set_xlabel(x_label, weight = 'bold', fontsize  = fontsize_plot)

[i.set_linewidth(2) for i in ax.spines.itervalues()] # change the width of the frame of the figure
ax.tick_params(axis='both', which='major', labelsize=fontsize_plot, size = 10, width = 2, pad = 7) 
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
 

bar_ap = ax.bar(ap_bin_center, hist_ap*100., ap_bin_center[1] - ap_bin_center[0], 0 , linewidth = 2)
nb_bar = len(bar_ap)
for ibar in range(nb_bar):
    colorVal = scalarMap.to_rgba(ibar)
    bar_ap[ibar].set_color(colorVal)

ax.margins(0,0)

fig_save_name = 'ap_probability'  
fig_save_name =  fig_save_name + '.pdf'
fig.savefig(fig_save_name, facecolor=fig.get_facecolor(), edgecolor='none', bbox_inches='tight')  

raise Exception

## Pc  as a function of Probability of Pc occuring
fig_title = ''
x_label = 'Probability'
y_label = '$P_C$'
fig = plt.figure(num=None, figsize=(height_fig * ratio_fig_size, height_fig), dpi=80, facecolor='w', edgecolor='k')
fig.suptitle(fig_title, y = 0.965,fontsize = (int)(fontsize_plot*1.1), weight = 'bold',)
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
gs = gridspec.GridSpec(1, 1)
gs.update(left = 0.11, right=0.87, top = 0.93,bottom = 0.12, hspace = 0.01)
ax = fig.add_subplot(gs[0, 0])

ax.set_ylabel(y_label, weight = 'bold', fontsize  = fontsize_plot)
ax.set_xlabel(x_label, weight = 'bold', fontsize  = fontsize_plot)

[i.set_linewidth(2) for i in ax.spines.itervalues()] # change the width of the frame of the figure
ax.tick_params(axis='both', which='major', labelsize=fontsize_plot, size = 10, width = 2, pad = 7) 
plt.rc('font', weight='bold') ## make the labels of the ticks in bold

ax.plot(pc_sort_on_prob[:, 1], pc_sort_on_prob[:, 0] , linewidth = 2, color = 'k')
ax.scatter(pc_sort_on_prob[:, 1], pc_sort_on_prob[:, 0] , linewidth = 2, color = 'k')
for irun in range(nb_run):
    ax.text(pc_sort_on_prob[irun, 1], pc_sort_on_prob[irun, 0], str(pc_sort_on_prob[irun, 3]) + ', ' + str( pc_sort_on_prob[irun, 5]), weight = 'bold', fontsize = fontsize_plot/1.2, horizontalalignment = 'center', verticalalignment = 'bottom', color =  'k')
ax.set_xlim([np.min(pc_sort_on_prob[:, 1]), np.max(pc_sort_on_prob[:, 1])])
ax.margins(0,0)

# pc[irun,:]:  0 pc, 1 probability of (f107,ap) to occur, 2 probablity of f107 to occur, 3 f107, 4 probablity of ap to occur, 5 ap

fig_save_name = 'pc_vs_prob'  
fig_save_name =  fig_save_name + '.pdf'
fig.savefig(fig_save_name, facecolor=fig.get_facecolor(), edgecolor='none', bbox_inches='tight')  


# Probability as a function of Ap anf F10.7
fig_title = ''
z_label = 'Probability'
y_label = 'Ap'
x_label = 'F10.7'
fig = plt.figure(num=None, figsize=(height_fig * ratio_fig_size, height_fig), dpi=80, facecolor='w', edgecolor='k')
fig.suptitle(fig_title, y = 0.965,fontsize = (int)(fontsize_plot*1.1), weight = 'bold',)
plt.rc('font', weight='bold') ## make the labels of the ticks in bold
gs = gridspec.GridSpec(1, 1)
gs.update(left = 0.11, right=0.87, top = 0.93,bottom = 0.12, hspace = 0.01)
ax = fig.add_subplot(gs[0, 0], projection = '3d')

ax.set_zlabel(z_label, weight = 'bold', fontsize  = fontsize_plot)
ax.set_ylabel(y_label, weight = 'bold', fontsize  = fontsize_plot)
ax.set_xlabel(x_label, weight = 'bold', fontsize  = fontsize_plot)

[i.set_linewidth(2) for i in ax.spines.itervalues()] # change the width of the frame of the figure
ax.tick_params(axis='both', which='major', labelsize=fontsize_plot, size = 10, width = 2, pad = 7) 
plt.rc('font', weight='bold') ## make the labels of the ticks in bold

X, Y = np.meshgrid(f107_bin_center, ap_bin_center)


#ax.plot(pc_sort_on_prob[:, 3], pc_sort_on_prob[:, 5], pc_sort_on_prob[:, 1] , linewidth = 2, color = 'k')

fig_save_name = 'prob_vs_f107_ap'  
fig_save_name =  fig_save_name + '.pdf'
fig.savefig(fig_save_name, facecolor=fig.get_facecolor(), edgecolor='none', bbox_inches='tight')  

