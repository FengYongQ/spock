# This script compares the state from TLEs to the state propagated by SpOCK.
# The analysis starts at a start epoch (start_epoch) and ends at an end epoch (end_epoch). SpOCK propagates the sc from the TLE at spacectrack.org which epoch corresponds to this start epoch until the end epoch. The propagated state from start_epoch to end_epoch is then compared to the state derived from the TLEs at spacetrack for this same period (from start_epoch to end_epoch).
# Note: to derive the state from the TLEs and compare them with the propagated stated by SpOCK, you first need to call SGP4 to convert the elements from the TLEs into r, v ECI (this is because TLEs are mean elements generated by SPG4 so to convert them in r, v you need to use the same model that generated them (which is SGP4)). SGP4 is implemented in SpOCK via SPICE libraries so SpOCK does the conversion TLEs to r, v ECI at the epoch of the TLEs. In addition to giving r, v ECI from the TLEs, SpOCK also gives the osculating orbital elements (by converting r, v ECI into osculating elements). Therefore, r, v ECI and osculating elements corresponding to the TLEs can be compared to r, v ECI and osculating elements corresponding to the propagation by SpOCK. (I actually compated r, v ECI using SGP4 as implemented in SpOCK to using the actual SGP4 (fortran code) and got the exact same r, v ECI in both cases (using 721 for the gravitational constant mode in the SGP4 fortran code))
####
# ASSUMPTIONS:
# - nadir pointing
# - Cd in geometry file are all equal to cd_geo_file
# - the mass assumed for CYGNSS is 29 kg

from norad_id_to_cygnss_name import *
from spock_main_input import *
import matplotlib.colors as colors
import matplotlib.cm as cmx
from cadre_read_last_tle import *
from get_prop_dir import *
import matplotlib.gridspec as gridspec
from read_input_file import *
from convert_tle_date_to_date import *
from matplotlib.colors import LogNorm
import pickle
from eci_to_lvlh import *
import sys
import fileinput
import time
from datetime import datetime
import numpy as np
from matplotlib import pyplot as plt
import os
import subprocess
from get_name_mission import *
from find_in_read_input_order_variables import *
from sgp4.earth_gravity import wgs84
from sgp4.io import twoline2rv

plt.ion()

############ ASSUMPTIONS ############
# - all SpOCK's simulations (defined by run_list below) to analyze here have to be in the same run directory (defined by run_dir below)

############ PARAMETERS TO SET ############
## Run directory of SpOCK's simulations (no path, just the name)
run_dir = 'run.cygnss'

## List of SpOCK's simulations (name of the main input file, without path)
run_list = ["cd_CYGFM03_2017-01-22T22:15:17_128512.txt"#, "CYGFM05_100days_gravity_order_20.txt"#,"CYGFM05_100days_j2.txt", "CYGFM05_100days.txt" #"CYGFM05_100days.txt"
            ]
## Save or not the plots
save_results = 0

## Show or not the plots
show_plots = 1

## path of the folder where you want to store the results (pickle, image, video)
path_folder_results = get_prop_dir(1) + run_dir + '/output/python_out/' #get_prop_dir(2) + 'output/python_propagator/'

## If the second spacecraft was propagated from the same main input file in SpOCK as the first spacecraft, set same_spock_input_file to 1. Otherwise, set it to 0
same_spock_input_file = 0

## Parameters for the figure
height_fig = 11.  # the width is calculated as height_fig * 4/3.
fontsize_plot = 20 
ratio_fig_size = 4./3

# start and end of the simulation. The most recent TLE corresponding to start_epoch will be downloaded from spacetrack to initialize SpOCK.
start_epoch = '2017-01-22' # Please use format 'YYYY-MM-DD'
end_epoch = '2017-02-21' # Please use format 'YYYY-MM-DD'

# which norad_id to consider
norad_id = '41891' # has to be a string

# ############ ALGORITHM ############
# SOME PRE STUFF
# not_in_list = 1
# list_elements_can_be_plot = ['radius', 'speed', 'altitude', 'eccentricity', 'sma', 'radius_perigee', 'radius_apogee', 'argument_perigee', 'raan']
# for iarg in sys.argv:
#     if iarg in list_elements_can_be_plot:
#         not_in_list = 0
# if ( ( len(sys.argv) == 0 ) | ( not_in_list == 1 ) ):
#     print "Choose between: "
#     for ilist in range(len(list_elements_can_be_plot)):
#         print list_elements_can_be_plot[ilist]
#     raise Exception

earth_mu     = 398600.4418; # gravitational parameter (km^3/s^2)
earth_radius = 6378.137; # mean equatorial radius (km)
# END OF SOME PRE STUFF

root_save_fig_name = path_folder_results 

# # SPOCK PROPAGATION
# # Download the most recent TLE corresponding to start_epoch to initialize SpOCK
link = "https://www.space-track.org/basicspacedata/query/class/tle/NORAD_CAT_ID/" + norad_id + "/EPOCH/%3E" + start_epoch +  "/format/tle/emptyresult/show/orderby/EPOCH%20asc/limit/1"
os.chdir("../" + run_dir + "/input/tle/")
os.system("wget  --post-data='identity=cbv@umich.edu&password=cygnssisawesome' --cookies=on --keep-session-cookies --save-cookies=cookies.txt 'https://www.space-track.org/ajaxauth/login' -olog")
name_tle = norad_id + '_on_' + start_epoch + ".txt"
os.system("wget --limit-rate=100K --keep-session-cookies --load-cookies=cookies.txt " + link + " -O " + name_tle)
os.system("cp " +  name_tle + " ../../../srcPython/cygnss")
os.chdir("../../../srcPython")

# # Run SpOCK: run nb_run_spock runs, each run corresponding to a different mass (this is equivalent to modeling a different Cd)
cd_array = np.arange(2,4.1,2)#4.01,0.25)
cd_geo_file = 2.4 # all the cd in the geomtry file must be equal to cd_geo_file
cygnss_real_mass = 29.
cygnss_real_mass_times_cd_geo_file = cygnss_real_mass * cd_geo_file
mass_array = cygnss_real_mass_times_cd_geo_file / cd_array
nb_run_spock = len(cd_array)
for irun in range(nb_run_spock):
    ## Create main input file for SpOCK with this TLE
    main_input_filename = name_tle.replace(".txt", "") + "_cd_" + str(cd_array[irun]).replace(".","_") + ".txt"
    ### look at TLE epoch start: SpOCK needs to start earlier than the TLE epoch
    tle_file = open(get_prop_dir(1) + run_dir + "/input/tle/" + name_tle)
    read_tle_file = tle_file.readlines()
    tle_epoch_temp = ( read_tle_file[0].split()[3] ) # TLE epoch -> initial epoch of SpOCK
    tle_epoch = convert_tle_date_to_date(tle_epoch_temp)
    ### Set up the start epoch for the propagation with SpOCK
    dt_spock = 1 # dt that will be used to run SpOCK
    dt_spock_output = dt_spock
    date_start_spock = datetime.strftime(tle_epoch + timedelta(seconds = dt_spock), "%Y-%m-%dT%H:%M:%S") # ned to add dt to tle epoch to make sure that SpOCK starts earlier than the TLE epoch
    date_end_spock = end_epoch + "T00:00:00"
    ### Creates main input file to run SpOCK
    mass = mass_array[irun]
    order_gravity = 20
    forces = "drag sun_gravity moon_gravity"
    density_mode = 'dynamic'
    spock_main_input( # need to be in spokc/srcPython to run this script   
        run_dir, main_input_filename,
        # for TIME section
        date_start_spock,
        date_end_spock,
        dt_spock,
        # for SPACECRAFT section
        1,
        '0',
        mass,
        "cygnss_geometry_2016.txt",
        # for ORBIT section
        name_tle,
        # for FORCES section
        str(order_gravity),
        forces,
        density_mode,
        # for OUTPUT section
        "out",
        dt_spock_output,
        # for ATTITUDE section
        "nadir",
        # for GROUND_STATIONS section
        "0"

        )
        ############
        ### Run SpOCK with this main input file
    # os.chdir("../" + run_dir)
    # os.system("/usr/local/bin/mpirun -np 1 spock " + main_input_filename)
    # os.chdir("../srcPython")
#    raise Exception
    ## Read propagated state
    var_in, var_in_order = read_input_file(get_prop_dir(1) + run_dir + "/input/main_input/" + main_input_filename)
    output_file_path_list = var_in[find_in_read_input_order_variables(var_in_order, 'output_file_path_list')]; 
    output_file_name_list = var_in[find_in_read_input_order_variables(var_in_order, 'output_file_name_list')]; 
    if irun == 0:
        nb_steps = var_in[find_in_read_input_order_variables(var_in_order, 'nb_steps')]; 
        nb_sc = var_in[find_in_read_input_order_variables(var_in_order, 'nb_sc')]; 
        alt_spock = np.zeros([nb_run_spock, nb_steps]); sma_spock = np.zeros([nb_run_spock, nb_steps]); radius_spock = np.zeros([nb_run_spock, nb_steps]); ecc_spock = np.zeros([nb_run_spock, nb_steps]);
    isc = 0 # here only one sc in main input file
    var_to_read = ["altitude", "sma", "radius", "eccentricity"]
    var_out, var_out_order = read_output_file( output_file_path_list[isc] + output_file_name_list[isc], var_to_read )
    if irun  == 0:
        date_spock = var_out[find_in_read_input_order_variables(var_out_order, 'date')]
    alt_spock[irun, :] = var_out[find_in_read_input_order_variables(var_out_order, 'altitude')]
    sma_spock[irun, :] = var_out[find_in_read_input_order_variables(var_out_order, 'sma')]
    radius_spock[irun, :] = var_out[find_in_read_input_order_variables(var_out_order, 'radius')]
    ecc_spock[irun, :] = var_out[find_in_read_input_order_variables(var_out_order, 'eccentricity')]






# TLE STATES
# Download all TLEs from start_epoch to end_epoch (all TLEs are included in the same file)
link = "https://www.space-track.org/basicspacedata/query/class/tle/NORAD_CAT_ID/" + norad_id + "/EPOCH/" + start_epoch + '--' + end_epoch +  "/format/tle/emptyresult/show/orderby/EPOCH%20asc/"
os.chdir("../" + run_dir + "/input/tle/")
os.system("wget  --post-data='identity=cbv@umich.edu&password=cygnssisawesome' --cookies=on --keep-session-cookies --save-cookies=cookies.txt 'https://www.space-track.org/ajaxauth/login' -olog")
name_all_tle_from_initial_to_end_epoch = norad_id + '_from_' + start_epoch + '_to_' + end_epoch + ".txt"
os.system("wget --limit-rate=100K --keep-session-cookies --load-cookies=cookies.txt " + link + " -O " + name_all_tle_from_initial_to_end_epoch)
os.system("cp " +  name_all_tle_from_initial_to_end_epoch + " ../../../srcPython/cygnss")
os.chdir("../../../srcPython")

# We can't just use 2 body equations to convert mean motion to sma and then compare this sma to the sma in SpOCK. Indeed, SpOCK uses osculating elements but the TLEs uses Kozai mean elements: they can differ by several km. So using the wrong theory (2 body equations) to convert the TLEs would give us errors, we need to use SGP4 because SGP4's equations convert Kozai mean elements into r, v ECI. Then we convert r, v ECI into osculating elements. Recall: SGP4 is integrated in SpOCK (via SPICE libraries) -> at the initialization, SpOCK converts the TLEs into r, v ECI and then osculating elements. So we just need to run the initialization part of SpOCK to convert the TLEs into osculating elements.
## For each TLE in name_all_tle_from_initial_to_end_epoch, run SpOCK for one step to convert TLEs into osculating elements
all_tle_file = open(get_prop_dir(1) + run_dir + "/input/tle/" + name_all_tle_from_initial_to_end_epoch)
read_all_tle_file = all_tle_file.readlines()
nb_tle = len(read_all_tle_file) / 2
date_tle = []
iline = 0
r_eci_tle = np.zeros([nb_tle,3])
radius_tle = np.zeros([nb_tle])
v_eci_tle = np.zeros([nb_tle,3])
alt_tle = np.zeros([nb_tle])
sma_tle = np.zeros([nb_tle])
ecc_tle = np.zeros([nb_tle])
for itle in range(nb_tle):
    dt_tle = 1 # we don't care about dt here because we only look at the initialization
    dt_tle_output = dt_tle
    date_tle_temp = read_all_tle_file[iline].split()[3]  
    date_start_temp = convert_tle_date_to_date(date_tle_temp)
    date_tle.append(date_start_temp)
    date_start_tle = datetime.strftime(date_start_temp, "%Y-%m-%dt_tle%H:%M:%S.%f")
    date_start_spock = datetime.strftime(date_start_temp + timedelta(seconds = dt_tle), "%Y-%m-%dT%H:%M:%S") # make sur ethe initial epoch starts at least one time step after TLE epoch
    ### Create a TLE file for SpOCK with only the current TLE
    tle_filename_one_sc_one_time = norad_id + "_" + date_start_tle.replace(".","_") + ".txt"
    tle_file_one_sc_one_time = open("../" + run_dir + "/input/tle/" + tle_filename_one_sc_one_time, "w")
    print >> tle_file_one_sc_one_time, read_all_tle_file[iline].replace("\r", ""), read_all_tle_file[iline+1].replace("\r", "")
    tle_file_one_sc_one_time.close()
    ### Create main input file for SpOCK with this TLE
    main_input_filename = "TLE_" + norad_id + "_" + date_start_tle.replace(".","_") + ".txt"
    date_end_temp = date_start_temp + timedelta(seconds = 2 * dt_tle) 
    date_end_spock = datetime.strftime(date_end_temp, "%Y-%m-%dT%H:%M:%S")
    spock_main_input( # need to be in spock/srcPython to run this script   
        run_dir, main_input_filename,
    # for TIME section
    date_start_spock,
    date_end_spock,
    dt_tle,
    # for SPACECRAFT section
     1,
    '0',
    mass,
    "cygnss_geometry_2016.txt",
    # for ORBIT section
    tle_filename_one_sc_one_time,
    # for FORCES section
    str(order_gravity),
    forces,
density_mode,
    # for OUTPUT section
        "out",
    dt_tle_output,
    # for ATTITUDE section
    "nadir",
        # for GROUND_STATIONS section
        "0"

)
    ### Run SpOCK with this main input file
    os.chdir("../" + run_dir)
    os.system("/usr/local/bin/mpirun -np 1 spock " + main_input_filename)
    os.chdir("../srcPython")

    ### Read TLE output file (starts the with the prefix 'TLE_')
    #### Read main input filename to figure out the name of the output
    var_in, var_in_order = read_input_file(get_prop_dir(1) + run_dir + "/input/main_input/" + main_input_filename)
    output_file_path_list = var_in[find_in_read_input_order_variables(var_in_order, 'output_file_path_list')]; 
    output_file_name_list = var_in[find_in_read_input_order_variables(var_in_order, 'output_file_name_list')]; 
    tle_out_name = output_file_path_list[0] + 'TLE_' + output_file_name_list[0]
    #### Read TLE state
    tle_out = open(tle_out_name, "r")
    read_tle_out = tle_out.readlines()
    n_header = 12
    r_eci_tle[itle, 0] = read_tle_out[n_header].split()[2]; r_eci_tle[itle, 1] = read_tle_out[n_header].split()[3]; r_eci_tle[itle, 2] = read_tle_out[n_header].split()[4]; 
    radius_tle[itle] = np.sqrt( r_eci_tle[itle, 0]*r_eci_tle[itle, 0] + r_eci_tle[itle, 1]*r_eci_tle[itle, 1] + r_eci_tle[itle, 2]*r_eci_tle[itle, 2] )
    v_eci_tle[itle, 0] = read_tle_out[n_header].split()[5]; v_eci_tle[itle, 1] = read_tle_out[n_header].split()[6]; v_eci_tle[itle, 2] = read_tle_out[n_header].split()[7]; 
    alt_tle[itle] = read_tle_out[n_header].split()[10]
    sma_tle[itle] = read_tle_out[n_header].split()[11]
    ecc_tle[itle] = read_tle_out[n_header].split()[13]
    tle_out.close()

    ### move to next tle
    iline = iline + 2


# LINEAR INTERPOLATE SPOCK TO TLE
# Indeed, SpOCK outputs osculating elements that capture all effects of the parturbations, particularly the ones due to the non uniform density of the Earth. Therefore, short term periodic effects (variations of the osculating elements within an orbit) make it really hard to directly compare to the osculating elements converted from the TLEs since these are only 'screenshots' at a particular time (about every 24 hour there is a new TLE).
# So here we linear interpolate the osculating elements of SpOCK at the epochs of the TLEs.
## Epochs of TLEs
### date_start_ref is the oldest date between the epoch of the olderst tle and the initial epoch of SpOCK's propagation. So the way we made this analysis should always give date_start_ref = date_tle[0] but we just double check here
date_start_ref = datetime.strptime(date_spock[0], "%Y/%m/%d %H:%M:%S")
if date_start_ref > date_tle[0]:
    date_start_ref = date_tle[0] 

x_axis_tle = np.zeros([nb_tle]) # x_axis_tle is the number of seconds between each TLE epoch and date_start_ref
for itle in range(nb_tle):
    x_axis_tle[itle] = ( date_tle[itle] - date_start_ref ).total_seconds()


## Linear interpolate osculating elements of SpOCK (and altitude)
### Nb of seconds between each dt of SpOCK's propagation and date_start_ref
nb_seconds_between_step_and_date_start_ref = np.zeros([nb_steps])
for idt in range(nb_steps):
    nb_seconds_between_step_and_date_start_ref[idt] = ( datetime.strptime(date_spock[idt], "%Y/%m/%d %H:%M:%S") - date_start_ref ).total_seconds()
    
alt_spock_interpo = []
radius_spock_interpo = []
sma_spock_interpo = []
ecc_spock_interpo = []
date_spock_interpo = []
for irun in range(nb_run_spock):
    alt_spock_per_cd_run_interpo = []
    radius_spock_per_cd_run_interpo = []
    sma_spock_per_cd_run_interpo = []
    ecc_spock_per_cd_run_interpo = []
    for itle in range(nb_tle):
        if len( np.where(nb_seconds_between_step_and_date_start_ref <= x_axis_tle[itle])[0] ) > 0: # get the SpOCK step right before the TLE
            ti_index = np.max(np.where(nb_seconds_between_step_and_date_start_ref <= x_axis_tle[itle])[0])
            ti = nb_seconds_between_step_and_date_start_ref[ti_index]
            alt_spock_per_cd_run_at_ti = alt_spock[irun, ti_index]
            radius_spock_per_cd_run_at_ti = radius_spock[irun, ti_index]
            sma_spock_per_cd_run_at_ti = sma_spock[irun, ti_index]
            ecc_spock_per_cd_run_at_ti = ecc_spock[irun, ti_index]
            if ti_index + 1 < nb_steps:
                tf = nb_seconds_between_step_and_date_start_ref[ti_index+1]
                alt_spock_per_cd_run_at_tf = alt_spock[irun, ti_index+1]
                radius_spock_per_cd_run_at_tf = radius_spock[irun, ti_index+1]
                sma_spock_per_cd_run_at_tf = sma_spock[irun, ti_index+1]
                ecc_spock_per_cd_run_at_tf = ecc_spock[irun, ti_index+1]
                alt_slope = ( alt_spock_per_cd_run_at_tf - alt_spock_per_cd_run_at_ti ) / ( tf - ti )
                radius_slope = ( radius_spock_per_cd_run_at_tf - radius_spock_per_cd_run_at_ti ) / ( tf - ti )
                sma_slope = ( sma_spock_per_cd_run_at_tf - sma_spock_per_cd_run_at_ti ) / ( tf - ti )
                ecc_slope = ( ecc_spock_per_cd_run_at_tf - ecc_spock_per_cd_run_at_ti ) / ( tf - ti )
                alt_spock_per_cd_run_interpo.append( alt_slope * ( x_axis_tle[itle] - ti ) + alt_spock_per_cd_run_at_ti )
                radius_spock_per_cd_run_interpo.append( radius_slope * ( x_axis_tle[itle] - ti ) + radius_spock_per_cd_run_at_ti )
                sma_spock_per_cd_run_interpo.append( sma_slope * ( x_axis_tle[itle] - ti ) + sma_spock_per_cd_run_at_ti )
                ecc_spock_per_cd_run_interpo.append( ecc_slope * ( x_axis_tle[itle] - ti ) + ecc_spock_per_cd_run_at_ti )
                if irun == 0:
                    date_spock_interpo.append( x_axis_tle[itle] )
    alt_spock_interpo.append( alt_spock_per_cd_run_interpo )
    radius_spock_interpo.append( radius_spock_per_cd_run_interpo )
    sma_spock_interpo.append( sma_spock_per_cd_run_interpo )
    ecc_spock_interpo.append( ecc_spock_per_cd_run_interpo )

alt_spock_interpo = np.array( alt_spock_interpo )
radius_spock_interpo = np.array( radius_spock_interpo )
sma_spock_interpo = np.array( sma_spock_interpo )
ecc_spock_interpo = np.array( ecc_spock_interpo )


# COMPARE PROPAGATION TO TLEs
# date_end_ref is the most recent date between the end epoch of SpOCK's propagation and the last TLE epoch
date_end_ref = datetime.strptime(date_spock[-1], "%Y/%m/%d %H:%M:%S")
if date_end_ref < date_tle[-1]:
    date_end_ref = date_tle[-1] 

# nb_seconds_in_spock_prop = nb_steps * dt_spock
# nb_seconds_between_date_start_spock_and_date_start_ref = ( datetime.strptime(date_spock[0], "%Y/%m/%d %H:%M:%S") - date_start_ref ).total_seconds()
# x_axis_spock = np.arange(nb_seconds_between_date_start_spock_and_date_start_ref, nb_seconds_in_spock_prop, dt_spock) 
x_axis_spock = date_spock_interpo

## For plots, generate disctinct colors
NCURVES = nb_sc
np.random.seed(101)
curves = [np.random.random(20) for i in range(NCURVES)]
values = range(NCURVES)
jet = cm = plt.get_cmap('jet') 
cNorm  = colors.Normalize(vmin=0, vmax=values[-1])
scalarMap = cmx.ScalarMappable(norm=cNorm, cmap=jet)

marker_array = ['s','^','o','D','*','v','<', '>','x']
color_array = ['r','b'] 
if len(sys.argv) > 0: # useless
#    var_to_read = sys.argv[1:]
    isc = 0
    # Plot
    fig_title = 'Radius as a function of time for ' + norad_id_to_cygnss_name(norad_id)
    y_label = 'Radius (km)'
    x_label = 'Real time'
    fig = plt.figure(num=None, figsize=(height_fig * ratio_fig_size, height_fig), dpi=80, facecolor='w', edgecolor='k')

    fig.suptitle(fig_title, y = 0.965,fontsize = (int)(fontsize_plot*1.1), weight = 'bold',)
    plt.rc('font', weight='bold') ## make the labels of the ticks in bold
    gs = gridspec.GridSpec(1, 1)
    gs.update(left = 0.11, right=0.83, top = 0.93,bottom = 0.12, hspace = 0.01)
    ax = fig.add_subplot(gs[0, 0])

    ax.set_ylabel(y_label, weight = 'bold', fontsize  = fontsize_plot)
    ax.set_xlabel(x_label, weight = 'bold', fontsize  = fontsize_plot)

    [i.set_linewidth(2) for i in ax.spines.itervalues()] # change the width of the frame of the figure
    ax.tick_params(axis='both', which='major', labelsize=fontsize_plot, size = 10, width = 2, pad = 7) 
    plt.rc('font', weight='bold') ## make the labels of the ticks in bold
    for irun in range(nb_run_spock):
        colorVal = scalarMap.to_rgba(irun)
        y_axis_spock = radius_spock_interpo[irun, :]
        ax.plot(x_axis_spock, y_axis_spock, linewidth = 2, color = color_array[irun], label = str(cd_array[irun]), marker = marker_array[irun])

    y_axis_tle = radius_tle
    ax.plot(x_axis_tle, y_axis_tle, linewidth = 2, color = 'k', marker = 'o', label = 'TLE')

    if isc == nb_sc - 1:
        # x axis label is in real time
        ## all output files of one simulation have the same number of steps, and start at the same date
        nb_ticks_xlabel = 8
        nb_seconds_along_x_axis = ( date_end_ref - date_start_ref ).total_seconds()
        dt_xlabel =  nb_seconds_along_x_axis / nb_ticks_xlabel # dt for ticks on x axis (in seconds)
        xticks = np.arange(0, nb_seconds_along_x_axis + 1, dt_xlabel)
        date_list_str = []
        date_list = [date_start_ref + timedelta(seconds=x) for x in xticks]
        for i in range(len(xticks)):
            if dt_xlabel >= 3*24*3600:
                date_list_str.append( str(date_list[i])[5:10] )
            else:
                date_list_str.append( str(date_list[i])[5:10] + "\n" + str(date_list[i])[11:16] )
        ax.xaxis.set_ticks(xticks)
        ax.xaxis.set_ticklabels(date_list_str, fontsize = fontsize_plot)#, rotation='vertical')
        ax.margins(0,0); ax.set_xlim([min(xticks), max(xticks)])
#        ax.set_xlim([ax.get_xlim()[0], most_recent_tle_among_all_sc])

        legend = ax.legend(loc='center left', bbox_to_anchor=(1, 0.5), numpoints = 1,  title=norad_id_to_cygnss_name(norad_id) , fontsize = fontsize_plot)
        legend.get_title().set_fontsize(str(fontsize_plot))

        if save_results == 1:
            fig_save_name = 'tle_vs_spock_radius'
            fig_save_name = root_save_fig_name + fig_save_name + '.pdf'
            fig.savefig(fig_save_name, facecolor=fig.get_facecolor(), edgecolor='none', bbox_inches='tight')  


if show_plots == 1:
    plt.show(); plt.show();


# raise Exception
# if len(sys.argv) > 0: # useless
# #    var_to_read = sys.argv[1:]
#     isc = 0
#     # Plot
#     fig_title = 'Altitude as a function of time'
#     y_label = 'Altitude (km)'
#     x_label = 'Real time'
#     fig = plt.figure(num=None, figsize=(height_fig * ratio_fig_size, height_fig), dpi=80, facecolor='w', edgecolor='k')

#     fig.suptitle(fig_title, y = 0.965,fontsize = (int)(fontsize_plot*1.1), weight = 'bold',)
#     plt.rc('font', weight='bold') ## make the labels of the ticks in bold
#     gs = gridspec.GridSpec(1, 1)
#     gs.update(left = 0.11, right=0.83, top = 0.93,bottom = 0.12, hspace = 0.01)
#     ax = fig.add_subplot(gs[0, 0])

#     ax.set_ylabel(y_label, weight = 'bold', fontsize  = fontsize_plot)
#     ax.set_xlabel(x_label, weight = 'bold', fontsize  = fontsize_plot)

#     [i.set_linewidth(2) for i in ax.spines.itervalues()] # change the width of the frame of the figure
#     ax.tick_params(axis='both', which='major', labelsize=fontsize_plot, size = 10, width = 2, pad = 7) 
#     plt.rc('font', weight='bold') ## make the labels of the ticks in bold

#     colorVal = scalarMap.to_rgba(isc)

#     y_axis_spock = alt_spock_interpo
#     ax.plot(x_axis_spock, y_axis_spock, linewidth = 2, color = 'b', label = 'SpOCK')

#     y_axis_tle = alt_tle
#     ax.plot(x_axis_tle, y_axis_tle, linewidth = 2, color = 'r', label = 'TLE')

#     if isc == nb_sc - 1:
#         # x axis label is in real time
#         ## all output files of one simulation have the same number of steps, and start at the same date
#         nb_ticks_xlabel = 8
#         nb_seconds_along_x_axis = ( date_end_ref - date_start_ref ).total_seconds()
#         dt_xlabel =  nb_seconds_along_x_axis / nb_ticks_xlabel # dt for ticks on x axis (in seconds)
#         xticks = np.arange(0, nb_seconds_along_x_axis + 1, dt_xlabel)
#         date_list_str = []
#         date_list = [date_start_ref + timedelta(seconds=x) for x in xticks]
#         for i in range(len(xticks)):
#             if dt_xlabel >= 3*24*3600:
#                 date_list_str.append( str(date_list[i])[5:10] )
#             else:
#                 date_list_str.append( str(date_list[i])[5:10] + "\n" + str(date_list[i])[11:16] )
#         ax.xaxis.set_ticks(xticks)
#         ax.xaxis.set_ticklabels(date_list_str, fontsize = fontsize_plot)#, rotation='vertical')
#         ax.margins(0,0); ax.set_xlim([min(xticks), max(xticks)])
# #        ax.set_xlim([ax.get_xlim()[0], most_recent_tle_among_all_sc])

#         legend = ax.legend(loc='center left', bbox_to_anchor=(1, 0.5), numpoints = 1,  title="SC #", fontsize = fontsize_plot)
#         legend.get_title().set_fontsize(str(fontsize_plot))

#         if save_results == 1:
#             fig_save_name = 'tle_vs_spock_altitude'
#             fig_save_name = root_save_fig_name + fig_save_name + '.pdf'
#             fig.savefig(fig_save_name, facecolor=fig.get_facecolor(), edgecolor='none', bbox_inches='tight')  

